[["index.html", "YOUR TITLE HERE Chapter 1 Down the rabbit-hole", " YOUR TITLE HERE YOUR NAME HERE 2021-10-21 Chapter 1 Down the rabbit-hole "],["the-pool-of-tears.html", "Chapter 2 The pool of tears", " Chapter 2 The pool of tears "],["a-caucus-race-and-a-long-tale.html", "Chapter 3 A caucus-race and a long tale", " Chapter 3 A caucus-race and a long tale "],["תנאים.html", "Chapter 4 תנאים 4.1 יש! אנחנו יכולים לשאול את המחשב שאלות 4.2 וריאציות", " Chapter 4 תנאים לעיתים קרובות אנחנו רוצים לשאול את המחשב שאלות. למשל, נרצה לפעמים לקבל תובה של כן או לא על שאלות כמו האם המספר הזה זוגי? האם המחרוזת שלי באורך של 4 תווים? הדרך לעשות זאת בשפות תכנות באופן כללי, וגם בשפת R בפרט היא בעזרת שאילתות של if else. שאילתה כזאת תקבל איזה פסוק לוגי, שיכול לקבל ערך של או אמת או שקר, ואנו נפרט לה מה להחזיר עבור אמת ומה להחזיר עבור שקר. בואו נראה דוגמא. 4.1 יש! אנחנו יכולים לשאול את המחשב שאלות נניח ויש לי מספר, x, שמכיל רנדומלי ערך מסויים, נגיד 5. x &lt;- 5 אני יכול לבקש מהמחשב להדפיס האם הערך של x הוא זוגי או אי זוגי. ראשית אראה איך לכתוב את הפסוק הלוגי שיענה לי על השאלה הזאת. עבור כך אני אעשה שימוש באופרטור ״מודולו״ שכותבים אותו ב R כך %%. את הביטוי 11 %% 3 נקרא באופן הבא: 11 מודלו שלוש, והמשמעות המתמטית של הביטוי היא מהי שארית החלוקה במספרים שלמים של 11 חלקי 3. התשובה לכך היא 2. באופן תכנותי ב R אכתוב את השאלה הזאת כך 11 %% 3 ## [1] 2 מעולה! נחזור לעניינו, אני רוצה לברר האם המספר שלי x הוא זוגי או אי-זוגי. עבור כל מספר זוגי, שארית החלוקה ב 2 היא 0, ועבור כל מספר אי-זוגי שארית החלוקה ב 2 היא 1. לכך כדי לקבל תשובה של אמת או שקר על האם x הוא זוגי אכתוב ב R x %% 2 == 0 ## [1] FALSE זה התנאי ששאילתת ה ifelse שלנו תקבל. המבנה של שאילתת ifelse נראה כך: if(&quot;פסוק לוגי שיכול לקבל ערך של אמת או שקר&quot;){ &quot;פקודות של מה שיקרה אם הפסוק הוא פסוק אמת&quot; } else { &quot;פקודות של מה יקרה אם הפסוק הוא פסוק שקר&quot; } נראה דוגמא: if(x %% 2 == 0){ print(&quot;wow, x is even!&quot;) } else { print(&quot;look, x is odd!&quot;) } ## [1] &quot;look, x is odd!&quot; בגלל שערך של x הוא 5, x הוא אי-זוגי, התנאי בשאילתה קיבל ערך FALSE ולכן רצו רק הפקודות בתוך הסוגריים המסולסלים של ה else ולא רצו כלל הפקודות בתוך הסוגריים המסולסלים של ה if מגניב. 4.2 וריאציות ניתן לכלול יותר מתנאי אחד בשאילתת ifelse, למשל אני רוצה לחלק את הקלטים המספריים שלי באופן הבא: אם x זוגי וגדול מ 10, תדפיס ״ big-even\" אם x שווה בדיוק ל 1 תדפיס ״the one and only\" בכל מקרה אחר, תדפיס ״orrrr\" ב R הפקידה הזאת תראה כך: if(x %% 2 == 0 &amp; x &gt; 10){ print(&quot;big-even&quot;) } else if(x == 1){ print(&quot;the one and only&quot;) } else{ print(&quot;orrrr&quot;) } ## [1] &quot;orrrr&quot; באותה הדרך אנחנו יכולים להוסיף כמה תנאי שרק נראה, רק חשוב לשים לב שכותבים את הקוד בדיוק האותו האופן שכתבתי פה. 4.2.1 ifelse פקודה סופר שימושים ב R נקראת ifelse והיא משתמש ליצירת שאילתת תנאי על וקטור שלם. נניח שיש לי את הוקטור הרנדומלי הבא: rand_v &lt;- sample(1:100, 20) print(rand_v) ## [1] 83 20 51 46 27 19 31 44 50 88 66 6 62 14 82 68 ## [17] 24 99 58 40 ואני רוצה לשאול עבור כך ערך בנפרד האם הוא זוגי או אי-זוגי - אשתמש בשביל זה בפונקציה ifelse. הדרך לכתוב אותה היא כזאת: ifelse(&quot;מבחן על וקטור&quot; , &quot;מה להחזיר עם המבחן מצליח&quot;, &quot;מה להחזיר אם הוא לא מצליח&quot; ) ודוגמא לעניננו בפועל: ifelse(rand_v %% 2 == 0, &quot;good&quot;, &quot;why???&quot;) ## [1] &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; ## [6] &quot;why???&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; ## [11] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; ## [16] &quot;good&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; הפלט של הפונקציה הוא וקטור, ונוכל כמובן לשמור אותה לשימוש עתידי אם נרצה זאת. "],["לולאות.html", "Chapter 5 לולאות 5.1 for loops 5.2 while 5.3 apply", " Chapter 5 לולאות בשונה משפות תכנות רבות אחרות, R היא שפה וקטורית, כלומר רוב הפעולות והפונקציות הבסיסיות בה מוכוונות לעבודה עם מערכים, או וקטורים מראש. העובדה ש R היא שפה וקטורית מורידה משמעותית את התלות שלנו בשימוש בלולאות, אך לעיתים עדיין אנו נרצה להשתמש בהם. ללואות הן דרך לומר למחשב לבצע מספר רב של פעמיים פעולה דומה, ללא צורך בלכתוב קוד נפרד לכל פעולה. ישנם מספר סוגי לולאות, העיקריות הן לולאות for אשר ישמשו אותנו לביצוע פעולה חזרתית מספר ידוע של פעמיים, ולולאות while אשר יבצעו עוד ועוד חזרות, עד אשר תנאי שנגדיר יתקיים. 5.1 for loops for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 5.2 while n &lt;- 10 i &lt;- 1 while(i &lt; n){ print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 5.3 apply matrix &lt;- matrix(1:24, 6, 4) matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 2 8 14 20 ## [3,] 3 9 15 21 ## [4,] 4 10 16 22 ## [5,] 5 11 17 23 ## [6,] 6 12 18 24 apply(matrix, 1, sum) ## [1] 40 44 48 52 56 60 apply(matrix, 2, sum) ## [1] 21 57 93 129 "],["פונקציות.html", "Chapter 6 פונקציות 6.1 למה לכתוב פונקציות? 6.2 מגניב, איך עושים את זה? 6.3 כמה דוגמאות", " Chapter 6 פונקציות עד עכשיו יצא לנו להכיר פונקציות רבות ב base-r. בנוסף לפונקציות שהשתמשנו בהם, שאנשים אחרים תכנתו עבורונו, אנחנו יכולים לתכנת בעצמנו פונקציות שיעשו איזה משימה שנטיל עליהן! 6.1 למה לכתוב פונקציות? אם אנחנו מוצאים את עצמנו עושים את אותה הפעולה באופן חזרתי שוב ושוב, אנחנו סתם מבזבזים זמן בהקלדה מיותרת ומייגעת. בנוסף, הקוד החזרתי מקשה על הקריאה של הסקריפט שלנו. שימוש בפונקציות, שאותן נגדיר בראש הסקריפט שלנו, או בסקריפט אחר, יהפכו את הקוד שלנו ל״נקי״ ו״קריא״ יותר. 6.2 מגניב, איך עושים את זה? המבנה של כתיבת פונקציה נראה כך: name_of_my_function &lt;- function(input_1, ..., input_n){ code . . . code return(my_output) } כלומר, אנחנו מגדירים פונקציה בשם שאנחנו בוחרים, וקובעים שמות למשתנים שהפונקציה תקבל. לאחר מכן, בתוך הסוגריים המעוגלים, נעשה פעולות על הקלטים של הפונקציה, ונבסוף, נחזיר את מה שנרצה בתוך הפקודה return 6.3 כמה דוגמאות 6.3.1 דוגמא ראשונה - פונקציה שמקבלת משוואה רבועית, ומחזירה את שורשיה משוואה ריבועית היא משוואה מהצורה הזאת \\[ f(x) = a \\cdot x^2 + b \\cdot x + c \\] שורשים של משוואה כזאת מוגדרים להיות ערכי ה \\(x\\) אשר עבורם המשוואה שווה ל \\(0\\) . יש למשוואה רבועית נוסחא סגורה ומפורסת, שאני מניח שרובנו נתקלנו בה אי-אז בימי בית הספר העליזים. \\[ x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] כאשר \\(a, b, c\\) הם מקדמי המשוואה כפי שהגדרנו. אנחנו נכתוב עכשיו פונקציה פשוטה יחסית ב R שעבור כל משוואה ריבועית, תגיש לנו על מגש של כסף את פתרונותיה. התשובה תתקבל במהירות, והתוכנה תמיד תחזיר לנו תשובה נכונה, איזה כי, זה לתכנת, אה? אחלה. נתחיל. נקרא לפונציה שלנו sqrt_res, היא תקבל שלושה ערכים, שכולם יהיו מספרים, \\(a, b, c\\) אשר יתארו במדוייק את המשוואה הריבועית שעבורה אנחנו מעוניינים למצוא שורשים. הפלט שלה יהיה וקטור באורך 2. למשוואה רבועית יכולים להיות לכל היותר 2 פתרונות ממשיים, אך יישנן משוואות רבועיות שיש להן פתרון יחיד, או אפס פתרונות. במקרה הזה, הפונקציה שלנו תחזיר בוקטור ערכים חסרים sqrt_res &lt;- function(a, b, c){ if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } בואו נעשה שימוש בפונקציה שלנו! \\[ f(x) = x^2 \\] sqrt_res(a = 1, b = 0, c = 0) ## [1] 0 NA \\[ f(x) = x^2 + 3 \\] sqrt_res(a = 1, b = 0, c = 3) ## [1] NA NA \\[ f(x) = 2x^2 + 3x + 1 \\] sqrt_res(a = 2, b = 3, c = 1) ## [1] 0.2807764 -1.7807764 מגניב. יש לשים לב שאם הפונקציה שלנו היתה מקבלת קלטים לא רצויים, נניח מחרוזות במקום מספרים היא היתה ״נשברת״, כלומר לא עובדת כמו שרצינו שהיא תעבוד. ניתן להפוך את הפונקציה שלנו ל״חסינה״ לקלטים לא רצויים כך: sqrt_res &lt;- function(a, b, c){ if(class(c(a,b,c)) != &quot;numeric&quot;){ return(&quot;bad inputs!!!&quot;) } if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } נמשיך לדוגמא הבא. 6.3.2 דוגמא שניה "],["ספריות.html", "Chapter 7 ספריות 7.1 איך להוריד ולטעון ספריות 7.2 base-r 7.3 מבט על כל הפונקציות שיש בכל ספריה 7.4 pacman", " Chapter 7 ספריות ספריות, או באנגילת packages הן קבצים שאחנו יכולים להוריד וכך להוסיף פונקציות שימושיות לסביבת ה R שלנו, והרחיב את היקף הדברים שאנחנו יכולים לעשות בה. שפת R היא ״שפת קוד פתוח״ והמשמעות של זה היא שהתוכנה אינה שייכת לחברה מסחרית אחת, אלא היא נוצרה ומתוחזקת על ידי קהילת המשתמשים בה. בתור אחת משפות התכנות הפופולאריות ביותר בעולם, יש ל R מיליוני משתמשים אשר תורמים לפיתוח שלה. כתיבת ספריות קוד היא אחת מהדרכים הכי שכיחות של תרומה כזאת. כל משתמש יכול לכתוב ספריה שתכיל את הפונקציות שלו, ולשתף אותן ברחבי האינטרנט למשתמשים אחרים. כך שהרבה פעמים, כאשר נמצא את עצמנו מעוניינים לבצע פעולה מסובכת, נגלה שמישהו כבר פתור אותה, כתב את הפתרון בתור פונקציה בספרייה, ושיתף אותה איתנו, וכל שנותר לנו הוא להוריד את הספריה למחשב שלנו. 7.1 איך להוריד ולטעון ספריות להוריד ספריות זה ממש קל! 7.2 base-r נניח ואני רוצה להוריד את הספריה ggplot2 שהיא ספריה מדהימה ליצרית ויזואליזציות. כל שעלי לעשות הוא להשתמש בפונקציה install.packages ולהזין למה את שם הספריה שאני מעוניין להוריד בתור מרכאות install.packages(&quot;ggplot2&quot;) הרצת שורת הקוד הזאת תפנה לדף האינטרנט שבו מאוחסן הקוד של הספריה, ותוריד אותו למחשב האישי שלכם. כעת, בכל פעם שארצה להשתמש בספרייה הזאת, יהיו עלי להשתמש בפקודה library שתקבל את שם הספריה שאותה אני רוצה לטעון, אך הפעם ללא מרכאות. library(ggplot2) אפשר לחשוב על ההורדה של הספריה בתור קניית מצרכים מהסופר ואחסונם במזווה שלנו, ובטעינה של הספריה, הוצאה של המצרכים מהמזווה כדי להתחיל להכין איתם מנה מדהימה, או קוד אדיר! 7.3 מבט על כל הפונקציות שיש בכל ספריה כדי לראות את כל הפונקציות שכל ספריה מציעה, נרשום את שם הספריה, ונוסיף :: ואז תופיע לנו רשימה של הפונקציות שהספריה מכילה 7.4 pacman דרך מעט נוחה יותר בעיני לעשות זאת היא להשתמש במנהל ספריות. הספריה של R pacman תאפשר לנו להוריד ולטעון ספריות בפקודה אחת, ובאופן יותר קריא. נתחיל קודם כל בלהוריד את הספריה install.packages(&quot;pacman&quot;) כעת, נעשה שימוש בפקודה p_load כדי להוריד ולטעון את הספריות שאנחנו מעוניינים בהם. אם ספריה הורדה בעבר למחשב שלנו, pacman רק תטען אותה, ואם היא אינה הורדה בעבר למחשב שלנו היא גם תורד וגם תטען בפקודה אחת pacman::p_load( ggplot2, data.table, DT, lubridate ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
