[["index.html", "YOUR TITLE HERE 1 Down the rabbit-hole", " YOUR TITLE HERE YOUR NAME HERE 2021-10-21 1 Down the rabbit-hole "],["שימוש-ב-r-בתור-מחשבון.html", " 2 שימוש ב R בתור מחשבון 2.1 פעולות חשבון בסיסיות 2.2 פונקציות סטיסטיות 2.3 קצת לינארית", " 2 שימוש ב R בתור מחשבון בלה בלה בלה 2.1 פעולות חשבון בסיסיות 4 + 5 ## [1] 9 4*5 ## [1] 20 4 / 5 ## [1] 0.8 4**5 ## [1] 1024 4**0.5 ## [1] 2 sqrt(4) ## [1] 2 abs(-4) ## [1] 4 v &lt;- c(2, 9, 0, 4, 1, 9, 9, 6) max(v) ## [1] 9 min(v) ## [1] 0 sort(v) ## [1] 0 1 2 4 6 9 9 9 2.2 פונקציות סטיסטיות 2.2.1 ממוצע \\[ \\sum_{i=1}^n x_i = x_1 + x_2 + \\dots + x_n \\] \\[ \\bar x = \\frac{1}{n} \\sum_{i=1}^n x_i \\] ממוצע של וקטור מוגדר להיות הסכום של כל איבר, חלקי אורך הוקטור. בשפת R הפונציה לחישוב כל סכום כל איברי וקטור היא sum v &lt;- c(2, 9, 0, 4, 1, 9, 9, 6) print(v) ## [1] 2 9 0 4 1 9 9 6 sum(v) ## [1] 40 והפונקציה לחישוב אורך של וקטור היא length length(v) ## [1] 8 לכן, על ידי שילוב שתי הפונקציות, נוכל לחשב מהו הממוצע של הוקטור sum(v) / length(v) ## [1] 5 אך לא נצטרך לעשות זאת, כי ישנה פונקציה מובנת לחישוב הממוצע mean(v) ## [1] 5 2.2.2 שונות \\[ var(\\vec x) = \\sigma^2 = \\frac{1}{n} \\sum_{i = 1}^n (x_i - \\bar x)^2 \\] שונות של וקטור מוגדרת להיות ממוצע סכומי המרחק מהממוצע בריבוע. נשמע מעט מורכב, אך ניתן לפרק את החישוב למספר פעולות פשוטות יותר, והמורכבות תעלם. ראשית לשמור את הממוצע של v בתור משתנה בשם v_bar v_bar &lt;- mean(v) לאחר מכן נחשב את וקטור המרחקים מהממוצע v - v_bar ## [1] -3 4 -5 -1 -4 4 4 1 ונעלה את כל אחד מהמרחקים בריבוע (v - v_bar)**2 ## [1] 9 16 25 1 16 16 16 1 כעת, כל שנותר הוא לסכום את ריבועי המרחקים, ולחלק את הסכום באורך הוקטור sum((v - v_bar)**2) / length(v) ## [1] 12.5 אך החישוב המיגע יכול היה להחסוך, כי גם לחישוב השונות קיימת פונקציה מובנת ב R var(v) ## [1] 14.28571 2.2.3 סטיית תקן סטטית תקן מוגדרת להיות שורש השונות \\[ sd(\\vec x) = \\sigma_{\\vec x} = \\sqrt{ \\frac{1}{n} \\sum_{i = 1}^n (x_i - \\bar x)^2 } = \\sqrt{var(\\vec x)} \\] 2.2.4 חציון חציון מוגדר להיות הערך האמצעי בוקטור. כלומר הערך שמחציב מהערכים גדולים ממנו ומחציתם קטנים ממנו. לכן, ניתן לכתוב עבור וקטור \\(\\vec x\\) מסודר בסדר עולה בעל \\(n\\) איברים שהחציון שלו הוא האיבר המקיים: \\[ median(\\vec x) = \\begin{cases} \\frac{n}{2} &amp; \\text{if }\\ n \\text{ is even}\\\\ \\frac{n+1}{2} &amp; \\text{if }\\ n \\text{ is odd}\\\\ \\end{cases} \\] נחשב זאת ב R בעזרת הפונקציה median median(v) ## [1] 5 2.3 קצת לינארית בלה בלה בלה "],["סוגי-משתנים-אבני-הבניין-שלנו.html", " 3 סוגי משתנים: אבני הבניין שלנו 3.1 משתנים?? 3.2 integer 3.3 numeric 3.4 logical 3.5 character", " 3 סוגי משתנים: אבני הבניין שלנו 3.1 משתנים?? יש מספר משפחות של שפות תכנות. אחת מהמשפחות הכי שחיכות נקראת ״תכנות מונחה עצמים״. למשל, השפות Java ו Python כתובות בסגנון של תכנות מונחה עצמיים, וכך גם R. לעניינו, לא חשוב לעומק מה המשמעות של הדבר הזה, אך כן חשוב לדעת שכל פונקציה, משתנה או אוביקט ב R יהיה שייך לאיזו מחלקה, שיש לה מאפיינים שיחודים לה. לדוגמא, אפשר לחבר אוביקט מספרי לאוביקט מספרי אחר, אך אין משמעות לחיבור של אוביקט מספרי ומחרוזת. כדי לברר לאיזה מחלקה כל אוביקט משוייך, אנחנו יכולים להשתמש בפונקציה class class(1) ## [1] &quot;numeric&quot; class(&quot;1&quot;) ## [1] &quot;character&quot; אכתוב עכשיו על סוגי המשתנים הבסיסים ביותר שיש בשפת R אשר ישמשו בתור אבני הבסיס של כל פרויקט שנרצה לבנות. intenger &amp; numeric: משתנים מספרים, ההבדל בין השתיים הוא יחס לשינויים אחרי הנקודה העשרונית logical: משתנה שמקבלים ערך של או אמת או שקר character: מילים או אותיות, אנחנו נקרא למשתנים כאלה ״מחרוזות״ 3.2 integer משנה זה יכיל ערכים של מספרים שלמים. הסיבה שיש הפרדה בין סוג המחלקה של מסרים שלמים ומספרים עם נקודה עשרונית, היא שניתן לשמור בזכרון של המחשב מספרים שלמים באופן יעיל יותר, לכן, אם האוביקט שלנו מכיל מספרים שלמים בלבד עדיף למחשב לשמור אותו כך. מספרים שלמים יכולים להיות מוצגים כך 5 או כך 5L. על מספרים שלמים אפשר לבצע פעולות חשבוניות, בדומה לאלו שהצגנו בפרק על שימוש ב R בתור מחשבון. אך יש לשים לב שאם נבצע פעולה שתשנה את וקטור המספרים השלמים שלנו למספרים שיש להם מקודה עשרונית - סוג המשתנה ישונה גם הוא v &lt;- c(1L, 9L, 9L, 6L) class(v) ## [1] &quot;integer&quot; print(v / 2) ## [1] 0.5 4.5 4.5 3.0 print(class(v / 2)) ## [1] &quot;numeric&quot; 3.3 numeric זה סוג המשתנה שכנראה תעבדו איתו הכי הרבה. על וקטורי numeric אפשר לעשות פעולות חשבוניות מגוונות, כפי שהדגמנו בפרק הקודם. 3.4 logical משתנים אלו מקבלים ערכים של אמת או של שקר. הם ישמשו אותנו הרבה פעמים בתור סוג של כפתור, או מתג, אשר יעזור לנו לחלק קבוצה לשתי קבוצות, ביחס לקיום של תנאי שנגדיר. שם נוסף שנשתמש בו למשתנים האלו יהיה משתנים בוליאנים. הערכים היחידם שמשתנים בוליאנים יכולים לקבל הם TRUE ו- FALSE 3.4.1 טבלאות אמת בלה בלה בלה 3.4.2 all all(c(T,T,T,F,T)) ## [1] FALSE all(c(T,T,T,T,T)) ## [1] TRUE 3.4.3 any any(c(F,T,F,F)) ## [1] TRUE any(c(F,F,F,F)) ## [1] FALSE 3.5 character בלה בלה בלה "],["תנאים.html", " 4 תנאים 4.1 יש! אנחנו יכולים לשאול את המחשב שאלות 4.2 וריאציות", " 4 תנאים לעיתים קרובות אנחנו רוצים לשאול את המחשב שאלות. למשל, נרצה לפעמים לקבל תובה של כן או לא על שאלות כמו האם המספר הזה זוגי? האם המחרוזת שלי באורך של 4 תווים? הדרך לעשות זאת בשפות תכנות באופן כללי, וגם בשפת R בפרט היא בעזרת שאילתות של if else. שאילתה כזאת תקבל איזה פסוק לוגי, שיכול לקבל ערך של או אמת או שקר, ואנו נפרט לה מה להחזיר עבור אמת ומה להחזיר עבור שקר. בואו נראה דוגמא. 4.1 יש! אנחנו יכולים לשאול את המחשב שאלות נניח ויש לי מספר, x, שמכיל רנדומלי ערך מסויים, נגיד 5. x &lt;- 5 אני יכול לבקש מהמחשב להדפיס האם הערך של x הוא זוגי או אי זוגי. ראשית אראה איך לכתוב את הפסוק הלוגי שיענה לי על השאלה הזאת. עבור כך אני אעשה שימוש באופרטור ״מודולו״ שכותבים אותו ב R כך %%. את הביטוי 11 %% 3 נקרא באופן הבא: 11 מודלו שלוש, והמשמעות המתמטית של הביטוי היא מהי שארית החלוקה במספרים שלמים של 11 חלקי 3. התשובה לכך היא 2. באופן תכנותי ב R אכתוב את השאלה הזאת כך 11 %% 3 ## [1] 2 מעולה! נחזור לעניינו, אני רוצה לברר האם המספר שלי x הוא זוגי או אי-זוגי. עבור כל מספר זוגי, שארית החלוקה ב 2 היא 0, ועבור כל מספר אי-זוגי שארית החלוקה ב 2 היא 1. לכך כדי לקבל תשובה של אמת או שקר על האם x הוא זוגי אכתוב ב R x %% 2 == 0 ## [1] FALSE זה התנאי ששאילתת ה ifelse שלנו תקבל. המבנה של שאילתת ifelse נראה כך: if(&quot;פסוק לוגי שיכול לקבל ערך של אמת או שקר&quot;){ &quot;פקודות של מה שיקרה אם הפסוק הוא פסוק אמת&quot; } else { &quot;פקודות של מה יקרה אם הפסוק הוא פסוק שקר&quot; } נראה דוגמא: if(x %% 2 == 0){ print(&quot;wow, x is even!&quot;) } else { print(&quot;look, x is odd!&quot;) } ## [1] &quot;look, x is odd!&quot; בגלל שערך של x הוא 5, x הוא אי-זוגי, התנאי בשאילתה קיבל ערך FALSE ולכן רצו רק הפקודות בתוך הסוגריים המסולסלים של ה else ולא רצו כלל הפקודות בתוך הסוגריים המסולסלים של ה if מגניב. 4.2 וריאציות ניתן לכלול יותר מתנאי אחד בשאילתת ifelse, למשל אני רוצה לחלק את הקלטים המספריים שלי באופן הבא: אם x זוגי וגדול מ 10, תדפיס ״ big-even\" אם x שווה בדיוק ל 1 תדפיס ״the one and only\" בכל מקרה אחר, תדפיס ״orrrr\" ב R הפקידה הזאת תראה כך: if(x %% 2 == 0 &amp; x &gt; 10){ print(&quot;big-even&quot;) } else if(x == 1){ print(&quot;the one and only&quot;) } else{ print(&quot;orrrr&quot;) } ## [1] &quot;orrrr&quot; באותה הדרך אנחנו יכולים להוסיף כמה תנאי שרק נראה, רק חשוב לשים לב שכותבים את הקוד בדיוק האותו האופן שכתבתי פה. 4.2.1 ifelse פקודה סופר שימושים ב R נקראת ifelse והיא משתמש ליצירת שאילתת תנאי על וקטור שלם. נניח שיש לי את הוקטור הרנדומלי הבא: rand_v &lt;- sample(1:100, 20) print(rand_v) ## [1] 73 94 67 68 17 42 59 51 86 62 57 41 52 20 38 2 56 22 90 100 ואני רוצה לשאול עבור כך ערך בנפרד האם הוא זוגי או אי-זוגי - אשתמש בשביל זה בפונקציה ifelse. הדרך לכתוב אותה היא כזאת: ifelse(&quot;מבחן על וקטור&quot; , &quot;מה להחזיר עם המבחן מצליח&quot;, &quot;מה להחזיר אם הוא לא מצליח&quot; ) ודוגמא לעניננו בפועל: ifelse(rand_v %% 2 == 0, &quot;good&quot;, &quot;why???&quot;) ## [1] &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;why???&quot; &quot;good&quot; ## [10] &quot;good&quot; &quot;why???&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;good&quot; ## [19] &quot;good&quot; &quot;good&quot; הפלט של הפונקציה הוא וקטור, ונוכל כמובן לשמור אותה לשימוש עתידי אם נרצה זאת. "],["לולאות.html", " 5 לולאות 5.1 for loops 5.2 while 5.3 apply", " 5 לולאות בשונה משפות תכנות רבות אחרות, R היא שפה וקטורית, כלומר רוב הפעולות והפונקציות הבסיסיות בה מוכוונות לעבודה עם מערכים, או וקטורים מראש. העובדה ש R היא שפה וקטורית מורידה משמעותית את התלות שלנו בשימוש בלולאות, אך לעיתים עדיין אנו נרצה להשתמש בהם. ללואות הן דרך לומר למחשב לבצע מספר רב של פעמיים פעולה דומה, ללא צורך בלכתוב קוד נפרד לכל פעולה. ישנם מספר סוגי לולאות, העיקריות הן לולאות for אשר ישמשו אותנו לביצוע פעולה חזרתית מספר ידוע של פעמיים, ולולאות while אשר יבצעו עוד ועוד חזרות, עד אשר תנאי שנגדיר יתקיים. 5.1 for loops for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 5.2 while n &lt;- 10 i &lt;- 1 while(i &lt; n){ print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 5.3 apply matrix &lt;- matrix(1:24, 6, 4) matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 2 8 14 20 ## [3,] 3 9 15 21 ## [4,] 4 10 16 22 ## [5,] 5 11 17 23 ## [6,] 6 12 18 24 apply(matrix, 1, sum) ## [1] 40 44 48 52 56 60 apply(matrix, 2, sum) ## [1] 21 57 93 129 "],["פונקציות.html", " 6 פונקציות 6.1 למה לכתוב פונקציות? 6.2 מגניב, איך עושים את זה? 6.3 כמה דוגמאות", " 6 פונקציות עד עכשיו יצא לנו להכיר פונקציות רבות ב base-r. בנוסף לפונקציות שהשתמשנו בהם, שאנשים אחרים תכנתו עבורונו, אנחנו יכולים לתכנת בעצמנו פונקציות שיעשו איזה משימה שנטיל עליהן! 6.1 למה לכתוב פונקציות? אם אנחנו מוצאים את עצמנו עושים את אותה הפעולה באופן חזרתי שוב ושוב, אנחנו סתם מבזבזים זמן בהקלדה מיותרת ומייגעת. בנוסף, הקוד החזרתי מקשה על הקריאה של הסקריפט שלנו. שימוש בפונקציות, שאותן נגדיר בראש הסקריפט שלנו, או בסקריפט אחר, יהפכו את הקוד שלנו ל״נקי״ ו״קריא״ יותר. 6.2 מגניב, איך עושים את זה? המבנה של כתיבת פונקציה נראה כך: name_of_my_function &lt;- function(input_1, ..., input_n){ code . . . code return(my_output) } כלומר, אנחנו מגדירים פונקציה בשם שאנחנו בוחרים, וקובעים שמות למשתנים שהפונקציה תקבל. לאחר מכן, בתוך הסוגריים המעוגלים, נעשה פעולות על הקלטים של הפונקציה, ונבסוף, נחזיר את מה שנרצה בתוך הפקודה return 6.3 כמה דוגמאות 6.3.1 דוגמא ראשונה - פונקציה שמקבלת משוואה רבועית, ומחזירה את שורשיה משוואה ריבועית היא משוואה מהצורה הזאת \\[ f(x) = a \\cdot x^2 + b \\cdot x + c \\] שורשים של משוואה כזאת מוגדרים להיות ערכי ה \\(x\\) אשר עבורם המשוואה שווה ל \\(0\\) . יש למשוואה רבועית נוסחא סגורה ומפורסת, שאני מניח שרובנו נתקלנו בה אי-אז בימי בית הספר העליזים. \\[ x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] כאשר \\(a, b, c\\) הם מקדמי המשוואה כפי שהגדרנו. אנחנו נכתוב עכשיו פונקציה פשוטה יחסית ב R שעבור כל משוואה ריבועית, תגיש לנו על מגש של כסף את פתרונותיה. התשובה תתקבל במהירות, והתוכנה תמיד תחזיר לנו תשובה נכונה, איזה כי, זה לתכנת, אה? אחלה. נתחיל. נקרא לפונציה שלנו sqrt_res, היא תקבל שלושה ערכים, שכולם יהיו מספרים, \\(a, b, c\\) אשר יתארו במדוייק את המשוואה הריבועית שעבורה אנחנו מעוניינים למצוא שורשים. הפלט שלה יהיה וקטור באורך 2. למשוואה רבועית יכולים להיות לכל היותר 2 פתרונות ממשיים, אך יישנן משוואות רבועיות שיש להן פתרון יחיד, או אפס פתרונות. במקרה הזה, הפונקציה שלנו תחזיר בוקטור ערכים חסרים sqrt_res &lt;- function(a, b, c){ if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } בואו נעשה שימוש בפונקציה שלנו! \\[ f(x) = x^2 \\] sqrt_res(a = 1, b = 0, c = 0) ## [1] 0 NA \\[ f(x) = x^2 + 3 \\] sqrt_res(a = 1, b = 0, c = 3) ## [1] NA NA \\[ f(x) = 2x^2 + 3x + 1 \\] sqrt_res(a = 2, b = 3, c = 1) ## [1] 0.2807764 -1.7807764 מגניב. יש לשים לב שאם הפונקציה שלנו היתה מקבלת קלטים לא רצויים, נניח מחרוזות במקום מספרים היא היתה ״נשברת״, כלומר לא עובדת כמו שרצינו שהיא תעבוד. ניתן להפוך את הפונקציה שלנו ל״חסינה״ לקלטים לא רצויים כך: sqrt_res &lt;- function(a, b, c){ if(class(c(a,b,c)) != &quot;numeric&quot;){ return(&quot;bad inputs!!!&quot;) } if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } נמשיך לדוגמא הבא. 6.3.2 דוגמא שניה "],["ספריות.html", " 7 ספריות 7.1 איך להוריד ולטעון ספריות 7.2 base-r 7.3 מבט על כל הפונקציות שיש בכל ספריה 7.4 pacman", " 7 ספריות ספריות, או באנגילת packages הן קבצים שאחנו יכולים להוריד וכך להוסיף פונקציות שימושיות לסביבת ה R שלנו, והרחיב את היקף הדברים שאנחנו יכולים לעשות בה. שפת R היא ״שפת קוד פתוח״ והמשמעות של זה היא שהתוכנה אינה שייכת לחברה מסחרית אחת, אלא היא נוצרה ומתוחזקת על ידי קהילת המשתמשים בה. בתור אחת משפות התכנות הפופולאריות ביותר בעולם, יש ל R מיליוני משתמשים אשר תורמים לפיתוח שלה. כתיבת ספריות קוד היא אחת מהדרכים הכי שכיחות של תרומה כזאת. כל משתמש יכול לכתוב ספריה שתכיל את הפונקציות שלו, ולשתף אותן ברחבי האינטרנט למשתמשים אחרים. כך שהרבה פעמים, כאשר נמצא את עצמנו מעוניינים לבצע פעולה מסובכת, נגלה שמישהו כבר פתור אותה, כתב את הפתרון בתור פונקציה בספרייה, ושיתף אותה איתנו, וכל שנותר לנו הוא להוריד את הספריה למחשב שלנו. 7.1 איך להוריד ולטעון ספריות להוריד ספריות זה ממש קל! 7.2 base-r נניח ואני רוצה להוריד את הספריה ggplot2 שהיא ספריה מדהימה ליצרית ויזואליזציות. כל שעלי לעשות הוא להשתמש בפונקציה install.packages ולהזין למה את שם הספריה שאני מעוניין להוריד בתור מרכאות install.packages(&quot;ggplot2&quot;) הרצת שורת הקוד הזאת תפנה לדף האינטרנט שבו מאוחסן הקוד של הספריה, ותוריד אותו למחשב האישי שלכם. כעת, בכל פעם שארצה להשתמש בספרייה הזאת, יהיו עלי להשתמש בפקודה library שתקבל את שם הספריה שאותה אני רוצה לטעון, אך הפעם ללא מרכאות. library(ggplot2) אפשר לחשוב על ההורדה של הספריה בתור קניית מצרכים מהסופר ואחסונם במזווה שלנו, ובטעינה של הספריה, הוצאה של המצרכים מהמזווה כדי להתחיל להכין איתם מנה מדהימה, או קוד אדיר! 7.3 מבט על כל הפונקציות שיש בכל ספריה כדי לראות את כל הפונקציות שכל ספריה מציעה, נרשום את שם הספריה, ונוסיף :: ואז תופיע לנו רשימה של הפונקציות שהספריה מכילה 7.4 pacman דרך מעט נוחה יותר בעיני לעשות זאת היא להשתמש במנהל ספריות. הספריה של R pacman תאפשר לנו להוריד ולטעון ספריות בפקודה אחת, ובאופן יותר קריא. נתחיל קודם כל בלהוריד את הספריה install.packages(&quot;pacman&quot;) כעת, נעשה שימוש בפקודה p_load כדי להוריד ולטעון את הספריות שאנחנו מעוניינים בהם. אם ספריה הורדה בעבר למחשב שלנו, pacman רק תטען אותה, ואם היא אינה הורדה בעבר למחשב שלנו היא גם תורד וגם תטען בפקודה אחת pacman::p_load( ggplot2, data.table, DT, lubridate ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
