[["index.html", "מבוא לתכנות ב R 1 על הספר 1.1 איך לקרוא את הספר וההדרכות 1.2 יצירת קשר", " מבוא לתכנות ב R אופיר בצר 2021-10-18 1 על הספר הספר הזה נועד להיות מבוא בסיסי לתכנות בשפת R . זהו אינו ספר העוסק בניתוח נתונים, ואין לקרוא אותו ככזה. בנוסף זהו אינו ספר אשר מומלץ ללמוד ממנו את אופן החשיבה הנרכש מקורסי מבוא למדעי המחשב. הספר מכוון לתת מבוא קצר, אך מעמיק מספיק לכלים תכנותים בסייסים, אשר בעזרתם ניתן ללמוד בהמשך נושאים תכנותיים מורכבים יותר. לדעתי יש יתרון בלהתחיל ללמוד קודם כל איך לכתוב קוד, אפילו לפני שלומדים כלים סטטיסטים הרלוונטים לניתוח הנתונים עצמו, כי יכולת התכנות הבסיסית עשויה להיות מאיימת ולא מזמינה, אך ברגע שמתחילים ״לשחק״ קצת עם הקוד, והנושא הופך לבהיר, מגלים כמה זה כיף, והתיאבון להמשך הלמידה גודל פלאים. קריאה נעימה :) 1.1 איך לקרוא את הספר וההדרכות את הספר אני ממליץ ללמוד פרק אחר פרק, ובמקביל לעבוד עם סקריפט R פתוח, ולנסות בעצמכם לממש ולייצר וריאציות של מה שמוצג. זוהי הדרך הטובה ביותר ללמוד, ולצבור ניסיון במגוון הדרכים השונות שאפשר לכתוב קוד. בנוסף, עבור כל פרק בספר יצורף סרטון ווידאו שבו אעבור על החומר המוצג בספר. ניתן לצפות בסרטון במקביל לקריאה של הספר, עם זו דרך שבה אתם מעדיפים ללמוד. 1.2 יצירת קשר אם עולות שאלות, מצאתם שגיאת כתיב או חוסר דיוק, אשמח לשמוע. אפשר ליצור איתי קשר דרך כתובת המייל ophir.betser@gmail.com עידכון אחרון: 2021-10-31 20:55:19 "],["מה-היא-שפת-r.html", " 2 מה היא שפת R? 2.1 יתרונות וחסרונות בשימוש ב R 2.2 מדריך התקנה", " 2 מה היא שפת R? שפת R היא שפת תכנות פופאלרית לביצוע ניתוח סטטיסטים ואקדמים. ניתן לבצע בה משימות רבות הקשורות לעולם הזה, כמו בניית מודלי למידת מכונה, יצירת ויזאליזציות, כתיבת מאמרים, בניית אפליקציות רשת ועד הרבה דברים אחרים. R היא שפת קוד פתוח, וככזו, היא מתוחזקת על ידי מיליוני משתמשים ברחבי העולם אשר תורמים לפיתוח מתשמך שלה, ומרחיבים את היכולות שלה מידי יום! 2.1 יתרונות וחסרונות בשימוש ב R 2.1.1 יתרונות קהילה אקדמית גדולה נוחה לשימוש למשתמש מיומן כלים מתקדמים לתיקשור ממצאיים מחקריים כוח חישוב רב: מהירה ובעלת יכולת התמודדות עם מסדי נתונים גדולים 2.1.2 חסרונות לא פופלארית בתעשיה דורשת עקומת למידה אינה שגורה במקומות עבודה רגילים 2.2 מדריך התקנה 2.2.1 למשתמשי וינדאוס 2.2.2 למשתמשי macos "],["שימוש-ב-r-בתור-מחשבון.html", " 3 שימוש ב R בתור מחשבון 3.1 פעולות חשבון בסיסיות 3.2 פונקציות סטיסטיות 3.3 קצת לינארית", " 3 שימוש ב R בתור מחשבון ברמה הבסיסית של R - ניתן להשתמש בתוכנה בתוך מחשבון מדעי סופר משוכלל. 3.1 פעולות חשבון בסיסיות 3.1.1 חיבור וחיסור 4 + 5 ## [1] 9 4 - 5 ## [1] -1 3.1.2 כפל וחילוק 4*5 ## [1] 20 4 / 5 ## [1] 0.8 3.1.3 חזקות 4**5 ## [1] 1024 3.1.4 פונקציות משלימות 3.1.4.1 ערך מוחלט abs(-4) ## [1] 4 3.1.4.2 מקסימום ומינימום v &lt;- c(2, 9, 0, 4, 1, 9, 9, 6) max(v) ## [1] 9 min(v) ## [1] 0 3.1.4.3 סידור וקטור מספרי sort(v) ## [1] 0 1 2 4 6 9 9 9 3.2 פונקציות סטיסטיות 3.2.1 ממוצע \\[ \\sum_{i=1}^n x_i = x_1 + x_2 + \\dots + x_n \\] \\[ \\bar x = \\frac{1}{n} \\sum_{i=1}^n x_i \\] ממוצע של וקטור מוגדר להיות הסכום של כל איבר, חלקי אורך הוקטור. בשפת R הפונציה לחישוב כל סכום כל איברי וקטור היא sum v &lt;- c(2, 9, 0, 4, 1, 9, 9, 6) print(v) ## [1] 2 9 0 4 1 9 9 6 sum(v) ## [1] 40 והפונקציה לחישוב אורך של וקטור היא length length(v) ## [1] 8 לכן, על ידי שילוב שתי הפונקציות, נוכל לחשב מהו הממוצע של הוקטור sum(v) / length(v) ## [1] 5 אך לא נצטרך לעשות זאת, כי ישנה פונקציה מובנת לחישוב הממוצע mean(v) ## [1] 5 3.2.2 שונות \\[ var(\\vec x) = \\sigma^2 = \\frac{1}{n} \\sum_{i = 1}^n (x_i - \\bar x)^2 \\] שונות של וקטור מוגדרת להיות ממוצע סכומי המרחק מהממוצע בריבוע. נשמע מעט מורכב, אך ניתן לפרק את החישוב למספר פעולות פשוטות יותר, והמורכבות תעלם. ראשית לשמור את הממוצע של v בתור משתנה בשם v_bar v_bar &lt;- mean(v) לאחר מכן נחשב את וקטור המרחקים מהממוצע v - v_bar ## [1] -3 4 -5 -1 -4 4 4 1 ונעלה את כל אחד מהמרחקים בריבוע (v - v_bar)**2 ## [1] 9 16 25 1 16 16 16 1 כעת, כל שנותר הוא לסכום את ריבועי המרחקים, ולחלק את הסכום באורך הוקטור sum((v - v_bar)**2) / length(v) ## [1] 12.5 אך החישוב המיגע יכול היה להחסוך, כי גם לחישוב השונות קיימת פונקציה מובנת ב R var(v) ## [1] 14.28571 3.2.3 סטיית תקן סטטית תקן מוגדרת להיות שורש השונות \\[ sd(\\vec x) = \\sigma_{\\vec x} = \\sqrt{ \\frac{1}{n} \\sum_{i = 1}^n (x_i - \\bar x)^2 } = \\sqrt{var(\\vec x)} \\] 3.2.4 חציון חציון מוגדר להיות הערך האמצעי בוקטור. כלומר הערך שמחציב מהערכים גדולים ממנו ומחציתם קטנים ממנו. לכן, ניתן לכתוב עבור וקטור \\(\\vec x\\) מסודר בסדר עולה בעל \\(n\\) איברים שהחציון שלו הוא האיבר המקיים: \\[ median(\\vec x) = \\begin{cases} \\frac{n}{2} &amp; \\text{if }\\ n \\text{ is even}\\\\ \\frac{n+1}{2} &amp; \\text{if }\\ n \\text{ is odd}\\\\ \\end{cases} \\] נחשב זאת ב R בעזרת הפונקציה median median(v) ## [1] 5 3.3 קצת לינארית בלה בלה בלה "],["סוגי-משתנים-אבני-הבניין-שלנו.html", " 4 סוגי משתנים: אבני הבניין שלנו 4.1 משתנים?? 4.2 integer 4.3 numeric 4.4 logical 4.5 character", " 4 סוגי משתנים: אבני הבניין שלנו 4.1 משתנים?? יש מספר משפחות של שפות תכנות. אחת מהמשפחות הכי שחיכות נקראת ״תכנות מונחה עצמים״. למשל, השפות Java ו Python כתובות בסגנון של תכנות מונחה עצמיים, וכך גם R. לעניינו, לא חשוב לעומק מה המשמעות של הדבר הזה, אך כן חשוב לדעת שכל פונקציה, משתנה או אוביקט ב R יהיה שייך לאיזו מחלקה, שיש לה מאפיינים שיחודים לה. לדוגמא, אפשר לחבר אוביקט מספרי לאוביקט מספרי אחר, אך אין משמעות לחיבור של אוביקט מספרי ומחרוזת. כדי לברר לאיזה מחלקה כל אוביקט משוייך, אנחנו יכולים להשתמש בפונקציה class class(1) ## [1] &quot;numeric&quot; class(&quot;1&quot;) ## [1] &quot;character&quot; אכתוב עכשיו על סוגי המשתנים הבסיסים ביותר שיש בשפת R אשר ישמשו בתור אבני הבסיס של כל פרויקט שנרצה לבנות. intenger &amp; numeric: משתנים מספרים, ההבדל בין השתיים הוא יחס לשינויים אחרי הנקודה העשרונית logical: משתנה שמקבלים ערך של או אמת או שקר character: מילים או אותיות, אנחנו נקרא למשתנים כאלה ״מחרוזות״ 4.2 integer משנה זה יכיל ערכים של מספרים שלמים. הסיבה שיש הפרדה בין סוג המחלקה של מסרים שלמים ומספרים עם נקודה עשרונית, היא שניתן לשמור בזכרון של המחשב מספרים שלמים באופן יעיל יותר, לכן, אם האוביקט שלנו מכיל מספרים שלמים בלבד עדיף למחשב לשמור אותו כך. מספרים שלמים יכולים להיות מוצגים כך 5 או כך 5L. על מספרים שלמים אפשר לבצע פעולות חשבוניות, בדומה לאלו שהצגנו בפרק על שימוש ב R בתור מחשבון. אך יש לשים לב שאם נבצע פעולה שתשנה את וקטור המספרים השלמים שלנו למספרים שיש להם מקודה עשרונית - סוג המשתנה ישונה גם הוא v &lt;- c(1L, 9L, 9L, 6L) class(v) ## [1] &quot;integer&quot; print(v / 2) ## [1] 0.5 4.5 4.5 3.0 print(class(v / 2)) ## [1] &quot;numeric&quot; 4.3 numeric זה סוג המשתנה שכנראה תעבדו איתו הכי הרבה. על וקטורי numeric אפשר לעשות פעולות חשבוניות מגוונות, כפי שהדגמנו בפרק הקודם. 4.4 logical משתנים אלו מקבלים ערכים של אמת או של שקר. הם ישמשו אותנו הרבה פעמים בתור סוג של כפתור, או מתג, אשר יעזור לנו לחלק קבוצה לשתי קבוצות, ביחס לקיום של תנאי שנגדיר. שם נוסף שנשתמש בו למשתנים האלו יהיה משתנים בוליאנים. הערכים היחידם שמשתנים בוליאנים יכולים לקבל הם TRUE ו- FALSE 4.4.1 טבלאות אמת בלה בלה בלה 4.4.2 all all(c(T,T,T,F,T)) ## [1] FALSE all(c(T,T,T,T,T)) ## [1] TRUE 4.4.3 any any(c(F,T,F,F)) ## [1] TRUE any(c(F,F,F,F)) ## [1] FALSE 4.5 character בלה בלה בלה "],["תנאים.html", " 5 תנאים 5.1 יש! אנחנו יכולים לשאול את המחשב שאלות 5.2 וריאציות", " 5 תנאים לעיתים קרובות אנחנו רוצים לשאול את המחשב שאלות. למשל, נרצה לפעמים לקבל תובה של כן או לא על שאלות כמו האם המספר הזה זוגי? האם המחרוזת שלי באורך של 4 תווים? הדרך לעשות זאת בשפות תכנות באופן כללי, וגם בשפת R בפרט היא בעזרת שאילתות של if else. שאילתה כזאת תקבל איזה פסוק לוגי, שיכול לקבל ערך של או אמת או שקר, ואנו נפרט לה מה להחזיר עבור אמת ומה להחזיר עבור שקר. בואו נראה דוגמא. 5.1 יש! אנחנו יכולים לשאול את המחשב שאלות נניח ויש לי מספר, x, שמכיל רנדומלי ערך מסויים, נגיד 5. x &lt;- 5 אני יכול לבקש מהמחשב להדפיס האם הערך של x הוא זוגי או אי זוגי. ראשית אראה איך לכתוב את הפסוק הלוגי שיענה לי על השאלה הזאת. עבור כך אני אעשה שימוש באופרטור ״מודולו״ שכותבים אותו ב R כך %%. את הביטוי 11 %% 3 נקרא באופן הבא: 11 מודלו שלוש, והמשמעות המתמטית של הביטוי היא מהי שארית החלוקה במספרים שלמים של 11 חלקי 3. התשובה לכך היא 2. באופן תכנותי ב R אכתוב את השאלה הזאת כך 11 %% 3 ## [1] 2 מעולה! נחזור לעניינו, אני רוצה לברר האם המספר שלי x הוא זוגי או אי-זוגי. עבור כל מספר זוגי, שארית החלוקה ב 2 היא 0, ועבור כל מספר אי-זוגי שארית החלוקה ב 2 היא 1. לכך כדי לקבל תשובה של אמת או שקר על האם x הוא זוגי אכתוב ב R x %% 2 == 0 ## [1] FALSE זה התנאי ששאילתת ה ifelse שלנו תקבל. המבנה של שאילתת ifelse נראה כך: if(&quot;פסוק לוגי שיכול לקבל ערך של אמת או שקר&quot;){ &quot;פקודות של מה שיקרה אם הפסוק הוא פסוק אמת&quot; } else { &quot;פקודות של מה יקרה אם הפסוק הוא פסוק שקר&quot; } נראה דוגמא: if(x %% 2 == 0){ print(&quot;wow, x is even!&quot;) } else { print(&quot;look, x is odd!&quot;) } ## [1] &quot;look, x is odd!&quot; בגלל שערך של x הוא 5, x הוא אי-זוגי, התנאי בשאילתה קיבל ערך FALSE ולכן רצו רק הפקודות בתוך הסוגריים המסולסלים של ה else ולא רצו כלל הפקודות בתוך הסוגריים המסולסלים של ה if מגניב. 5.2 וריאציות ניתן לכלול יותר מתנאי אחד בשאילתת ifelse, למשל אני רוצה לחלק את הקלטים המספריים שלי באופן הבא: אם x זוגי וגדול מ 10, תדפיס ״ big-even\" אם x שווה בדיוק ל 1 תדפיס ״the one and only\" בכל מקרה אחר, תדפיס ״orrrr\" ב R הפקודה הזאת תראה כך: if(x %% 2 == 0 &amp; x &gt; 10){ print(&quot;big-even&quot;) } else if(x == 1){ print(&quot;the one and only&quot;) } else{ print(&quot;orrrr&quot;) } ## [1] &quot;orrrr&quot; באותה הדרך אנחנו יכולים להוסיף כמה תנאי שרק נראה, רק חשוב לשים לב שכותבים את הקוד בדיוק האותו האופן שכתבתי פה. 5.2.1 ifelse פקודה סופר שימושים ב R נקראת ifelse והיא משתמש ליצירת שאילתת תנאי על וקטור שלם. נניח שיש לי את הוקטור הרנדומלי הבא: rand_v &lt;- sample(1:100, 20) print(rand_v) ## [1] 39 38 89 8 58 73 52 20 65 54 87 71 13 41 25 4 29 37 68 95 ואני רוצה לשאול עבור כך ערך בנפרד האם הוא זוגי או אי-זוגי - אשתמש בשביל זה בפונקציה ifelse. הדרך לכתוב אותה היא כזאת: ifelse(&quot;מבחן על וקטור&quot; , &quot;מה להחזיר עם המבחן מצליח&quot;, &quot;מה להחזיר אם הוא לא מצליח&quot; ) ודוגמא לעניננו בפועל: ifelse(rand_v %% 2 == 0, &quot;good&quot;, &quot;why???&quot;) ## [1] &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;why???&quot; ## [13] &quot;why???&quot; &quot;why???&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; הפלט של הפונקציה הוא וקטור, ונוכל כמובן לשמור אותה לשימוש עתידי אם נרצה זאת. "],["לולאות.html", " 6 לולאות 6.1 for loops 6.2 while 6.3 apply", " 6 לולאות בשונה משפות תכנות רבות אחרות, R היא שפה וקטורית, כלומר רוב הפעולות והפונקציות הבסיסיות בה מוכוונות לעבודה עם מערכים, או וקטורים מראש. העובדה ש R היא שפה וקטורית מורידה משמעותית את התלות שלנו בשימוש בלולאות, אך לעיתים עדיין אנו נרצה להשתמש בהם. ללואות הן דרך לומר למחשב לבצע מספר רב של פעמיים פעולה דומה, ללא צורך בלכתוב קוד נפרד לכל פעולה. ישנם מספר סוגי לולאות, העיקריות הן לולאות for אשר ישמשו אותנו לביצוע פעולה חזרתית מספר ידוע של פעמיים, ולולאות while אשר יבצעו עוד ועוד חזרות, עד אשר תנאי שנגדיר יתקיים. 6.1 for loops for(i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 6.2 while n &lt;- 10 i &lt;- 1 while(i &lt; n){ print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 6.3 apply matrix &lt;- matrix(1:24, 6, 4) matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 2 8 14 20 ## [3,] 3 9 15 21 ## [4,] 4 10 16 22 ## [5,] 5 11 17 23 ## [6,] 6 12 18 24 apply(matrix, 1, sum) ## [1] 40 44 48 52 56 60 apply(matrix, 2, sum) ## [1] 21 57 93 129 "],["פונקציות.html", " 7 פונקציות 7.1 למה לכתוב פונקציות? 7.2 מגניב, איך עושים את זה? 7.3 כמה דוגמאות", " 7 פונקציות עד עכשיו יצא לנו להכיר פונקציות רבות ב base-r. בנוסף לפונקציות שהשתמשנו בהם, שאנשים אחרים תכנתו עבורונו, אנחנו יכולים לתכנת בעצמנו פונקציות שיעשו איזה משימה שנטיל עליהן! 7.1 למה לכתוב פונקציות? אם אנחנו מוצאים את עצמנו עושים את אותה הפעולה באופן חזרתי שוב ושוב, אנחנו סתם מבזבזים זמן בהקלדה מיותרת ומייגעת. בנוסף, הקוד החזרתי מקשה על הקריאה של הסקריפט שלנו. שימוש בפונקציות, שאותן נגדיר בראש הסקריפט שלנו, או בסקריפט אחר, יהפכו את הקוד שלנו ל״נקי״ ו״קריא״ יותר. 7.2 מגניב, איך עושים את זה? המבנה של כתיבת פונקציה נראה כך: name_of_my_function &lt;- function(input_1, ..., input_n){ code . . . code return(my_output) } כלומר, אנחנו מגדירים פונקציה בשם שאנחנו בוחרים, וקובעים שמות למשתנים שהפונקציה תקבל. לאחר מכן, בתוך הסוגריים המעוגלים, נעשה פעולות על הקלטים של הפונקציה, ונבסוף, נחזיר את מה שנרצה בתוך הפקודה return 7.3 כמה דוגמאות 7.3.1 דוגמא ראשונה - פונקציה שמקבלת משוואה רבועית, ומחזירה את שורשיה משוואה ריבועית היא משוואה מהצורה הזאת \\[ f(x) = a \\cdot x^2 + b \\cdot x + c \\] שורשים של משוואה כזאת מוגדרים להיות ערכי ה \\(x\\) אשר עבורם המשוואה שווה ל \\(0\\) . יש למשוואה רבועית נוסחא סגורה ומפורסת, שאני מניח שרובנו נתקלנו בה אי-אז בימי בית הספר העליזים. \\[ x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] כאשר \\(a, b, c\\) הם מקדמי המשוואה כפי שהגדרנו. אנחנו נכתוב עכשיו פונקציה פשוטה יחסית ב R שעבור כל משוואה ריבועית, תגיש לנו על מגש של כסף את פתרונותיה. התשובה תתקבל במהירות, והתוכנה תמיד תחזיר לנו תשובה נכונה, איזה כי, זה לתכנת, אה? אחלה. נתחיל. נקרא לפונציה שלנו sqrt_res, היא תקבל שלושה ערכים, שכולם יהיו מספרים, \\(a, b, c\\) אשר יתארו במדוייק את המשוואה הריבועית שעבורה אנחנו מעוניינים למצוא שורשים. הפלט שלה יהיה וקטור באורך 2. למשוואה רבועית יכולים להיות לכל היותר 2 פתרונות ממשיים, אך יישנן משוואות רבועיות שיש להן פתרון יחיד, או אפס פתרונות. במקרה הזה, הפונקציה שלנו תחזיר בוקטור ערכים חסרים sqrt_res &lt;- function(a, b, c){ if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } בואו נעשה שימוש בפונקציה שלנו! \\[ f(x) = x^2 \\] sqrt_res(a = 1, b = 0, c = 0) ## [1] 0 NA \\[ f(x) = x^2 + 3 \\] sqrt_res(a = 1, b = 0, c = 3) ## [1] NA NA \\[ f(x) = 2x^2 + 3x + 1 \\] sqrt_res(a = 2, b = 3, c = 1) ## [1] 0.2807764 -1.7807764 מגניב. יש לשים לב שאם הפונקציה שלנו היתה מקבלת קלטים לא רצויים, נניח מחרוזות במקום מספרים היא היתה ״נשברת״, כלומר לא עובדת כמו שרצינו שהיא תעבוד. ניתן להפוך את הפונקציה שלנו ל״חסינה״ לקלטים לא רצויים כך: sqrt_res &lt;- function(a, b, c){ if(class(c(a,b,c)) != &quot;numeric&quot;){ return(&quot;bad inputs!!!&quot;) } if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } נמשיך לדוגמא הבאה. 7.3.2 דומגא שניה - שיטה נומרית לחישוב נגזרת נגדרת של פונקציה מוגדרת להיות הגבול הבא: \\[ f&#39;(x) = \\lim_{x_0 \\to x}{\\frac{f(x) - f(x_0)}{x-x_0}} \\] המשמעות של הגבול הזה היא כמה שינוי קטן מאוד בערך ה x משפיע על ערך ה y של הפונקציה. משוואה שקולה לחלוטין לחישוב הנגדרת היא \\[ f&#39;(x) = \\lim_{h \\to 0}{\\frac{f(x) - f(x + h)}{h}} \\] נוכל לחשב קירוב של הביטוי הזה בלי לחשב את הגבול. נקבע ערך ל h שיהיה מספר מאוד קטן, ונציב אותו במשוואת הגבול. אומנם לא נקבל תוצאה מדוייקת לחלוטין, ויש מקרים, כמו עבור פונקציות שערך הגבול הזה אינו מוגדר עבורן, שנקבל תוצאה שוגיה לחלוטין - בדרך כלל הקירוב שנקבל בשיטה הזאת, עבור פונקציות טריוואליות, יהיה מצויין. בדוגמא הזאת אני רוצה לעשות שימוש בפונקציה אנונימית עבור \\(f(x)\\). ניתן ליצור פונקציה ללא שתשמש אותנו. למשל פונקציה אנונימית שמקבלת מספר ומחזירה על הערך המוחלט שלו בריבוע function(x){(abs(x)^2)} ## function(x){(abs(x)^2)} נוכל לעשות שימוש בפונקציה עבור חישוב הנגזרת הנומרי שלנו derivative &lt;- function(f, x){ epssilon &lt;- 0.000001 return((f(x + epssilon) - f(x)) / epssilon) } בואו נשחק קצת עם הפונקציה החדשה שלנו! מה הערך של \\(f&#39;(3.14)\\) של \\[ f(x) = x^{2.71} - x + e^x \\] derivative(function(x){x^2.71 - x + exp(x)}, 3.14) ## [1] 41.27816 קל. מוזמנים לבדוק על ידי גזירה ידנית. "],["ספריות.html", " 8 ספריות 8.1 איך להוריד ולטעון ספריות 8.2 base-r 8.3 מבט על כל הפונקציות שיש בכל ספריה 8.4 pacman", " 8 ספריות ספריות, או באנגילת packages הן קבצים שאחנו יכולים להוריד וכך להוסיף פונקציות שימושיות לסביבת ה R שלנו, והרחיב את היקף הדברים שאנחנו יכולים לעשות בה. שפת R היא ״שפת קוד פתוח״ והמשמעות של זה היא שהתוכנה אינה שייכת לחברה מסחרית אחת, אלא היא נוצרה ומתוחזקת על ידי קהילת המשתמשים בה. בתור אחת משפות התכנות הפופולאריות ביותר בעולם, יש ל R מיליוני משתמשים אשר תורמים לפיתוח שלה. כתיבת ספריות קוד היא אחת מהדרכים הכי שכיחות של תרומה כזאת. כל משתמש יכול לכתוב ספריה שתכיל את הפונקציות שלו, ולשתף אותן ברחבי האינטרנט למשתמשים אחרים. כך שהרבה פעמים, כאשר נמצא את עצמנו מעוניינים לבצע פעולה מסובכת, נגלה שמישהו כבר פתור אותה, כתב את הפתרון בתור פונקציה בספרייה, ושיתף אותה איתנו, וכל שנותר לנו הוא להוריד את הספריה למחשב שלנו. 8.1 איך להוריד ולטעון ספריות להוריד ספריות זה ממש קל! 8.2 base-r נניח ואני רוצה להוריד את הספריה ggplot2 שהיא ספריה מדהימה ליצרית ויזואליזציות. כל שעלי לעשות הוא להשתמש בפונקציה install.packages ולהזין למה את שם הספריה שאני מעוניין להוריד בתור מרכאות install.packages(&quot;ggplot2&quot;) הרצת שורת הקוד הזאת תפנה לדף האינטרנט שבו מאוחסן הקוד של הספריה, ותוריד אותו למחשב האישי שלכם. כעת, בכל פעם שארצה להשתמש בספרייה הזאת, יהיו עלי להשתמש בפקודה library שתקבל את שם הספריה שאותה אני רוצה לטעון, אך הפעם ללא מרכאות. library(ggplot2) אפשר לחשוב על ההורדה של הספריה בתור קניית מצרכים מהסופר ואחסונם במזווה שלנו, ובטעינה של הספריה, הוצאה של המצרכים מהמזווה כדי להתחיל להכין איתם מנה מדהימה, או קוד אדיר! 8.3 מבט על כל הפונקציות שיש בכל ספריה כדי לראות את כל הפונקציות שכל ספריה מציעה, נרשום את שם הספריה, ונוסיף :: ואז תופיע לנו רשימה של הפונקציות שהספריה מכילה 8.4 pacman דרך מעט נוחה יותר בעיני לעשות זאת היא להשתמש במנהל ספריות. הספריה של R pacman תאפשר לנו להוריד ולטעון ספריות בפקודה אחת, ובאופן יותר קריא. נתחיל קודם כל בלהוריד את הספריה install.packages(&quot;pacman&quot;) כעת, נעשה שימוש בפקודה p_load כדי להוריד ולטעון את הספריות שאנחנו מעוניינים בהם. אם ספריה הורדה בעבר למחשב שלנו, pacman רק תטען אותה, ואם היא אינה הורדה בעבר למחשב שלנו היא גם תורד וגם תטען בפקודה אחת pacman::p_load( ggplot2, data.table, DT, lubridate ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
